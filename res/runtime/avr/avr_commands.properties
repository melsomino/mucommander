ADC = Add with Carry
ADD = Add without Carry
ADIW = Add Immediate to Word
AND = Logical AND
ANDI = Logical AND with Immediate
ASR = Arithmetic Shift Right
BCLR = Bit Clear in SREG
BLD = Bit Load from the T Flag in SREG to a Bit in Register
BRBC = Branch if Bit in SREG is Cleared
BRBS = Branch if Bit in SREG is Set
BRCC = Branch if Carry Cleared
BRCS = Branch if Carry Set
BREAK = Break
BREQ = Branch if Equal
BRGE = Branch if Greater or Equal (Signed)
BRHC = Branch if Half Carry Flag is Cleared
BRHS = Branch if Half Carry Flag is Set
BRID = Branch if Global Interrupt is Disabled
BRIE = Branch if Global Interrupt is Enabled
BRLO = Branch if Lower (Unsigned)
BRLT = Branch if Less Than (Signed)
BRMI = Branch if Minus
BRNE = Branch if Not Equal
BRPL = Branch if Plus
BRSH = Branch if Same or Higher (Unsigned)
BRTC = Branch if the T Flag is Cleared
BRTS = Branch if the T Flag is Set
BRVC = Branch if Overflow Cleared
BRVS = Branch if Overflow Set
BSET = Bit Set in SREG
BST = Bit Store from Bit in Register to T Flag in SREG
CALL = Long Call to a Subroutine
CBI = Clear Bit in I/O Register
CBR = Clear Bits in Register
CLC = Clear Carry Flag
CLH = Clear Half Carry Flag
CLI = Clear Global Interrupt Flag
CLN = Clear Negative Flag
CLR = Clear Register
CLS = Clear Signed Flag
CLT = Clear T Flag
CLV = Clear Overflow Flag
CLZ = Clear Zero Flag
COM = One's Complement
CP = Compare
CPC = Compare with Carry
CPI = Compare with Immediate
CPSE = Compare Skip if Equal
DEC = Decrement
DES = Data Encryption Standard
EICALL = Extended Indirect Call to Subroutine
EIJMP = Extended Indirect Jump
ELPM = Extended Load Program Memory
EOR = Exclusive OR
FMUL = Fractional Multiply Unsigned
FMULS = Fractional Multiply Signed
FMULSU = Fractional Multiply Signed with Unsigned
ICALL = Indirect Call to Subroutine
IJMP = Indirect Jump
IN = Load an I/O Location to Register
INC = Increment
JMP = Jump
LAC = Load and Clear
LAS = Load and Set
LAT = Load and Toggle
LD = Load Indirect from Data Space to Register using Index X
LDD = Load Indirect from Data Space to Register using Index X
LDI = Loads an 8 bit constant directly to register 16 to 31.
LDS = Load Direct from Data Space (Register File, I/O memory, SRAM)
LDS = Load Direct from Data Space (Register File, I/O memory, SRAM)
LPM = Load Program Memory, R0 <- (Z=R31:R30) 
LSL = Logical Shift Left
LSR = Logical Shift Right
MOV = Copy Register
MOVW = Copy Register Word, R(d+1):R(d) <- R(r+1):R(r)
MUL = Multiply Unsigned
MULS = Multiply Signed
MULSU = Multiply Signed with Unsigned
NEG = Two's Complement (Rd <- 0x00-Rd)
NOP = No Operation
OR = Logical OR
ORI = Logical OR with Immediate
OUT = Store Register to I/O Location
POP = Pop Register from Stack
PUSH = Push Register on Stack
RCALL = Relative Call to Subroutine
RET = Return from Subroutine
RETI = Return from Interrupt
RJMP = Relative Jump
ROL = Rotate Left trough Carry
ROR = Rotate Right through Carry
SBC = Subtract with Carry
SBCI = Subtract Immediate with Carry
SBI = Set Bit in I/O Register
SBIC = Skip if Bit in I/O Registeris Cleared
SBIS = Skip if Bit in I/O Register is Set
SBIW = Subtract Immediate from Word
SBR = Set Bits in Register
SBRC = Skip if Bit in Register is Cleared
SBRS = Skip if Bit in Register is Set
SEC = Set Carry Flag
SEH = Set Half Carry Flag
SEI = Set Global Interrupt Flag
SEN = Set Negative Flag
SER = Set all Bits in Register
SES = Set Signed Flag
SET = Set T Flag
SEV = Set Overflow Flag
SEZ = Set Zero Flag
SLEEP = Enter sleep mode
SPM = Store Program Memory
ST = Store Indirect From Register to Data Space using Index X, Y or Z
STD = Store Indirect From Register to Data Space using Index X, Y or Z
STS = Store Direct to Data Space (Register File, I/O memory, SRAM)
SUB = Subtract without Carry
SUBI = Subtract Immediate
SWAP = Swap Nibbles
TST = Test for Zero or Minus
WDR = Watchdog Reset
XCH = Exchange
